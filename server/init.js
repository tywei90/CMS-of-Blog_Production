module.exports = {
    articles: [{
        title: '欢迎使用博客系统',
        date: new Date(),
        content: "*** 此博客系统前端是用vue全家桶搭建的，负责路由跳转，是个单页面应用。后台用的nodejs的express框架，用mongoose驱动mongodb数据库来实现数据库管理。***\n  \n此博客系统支持一下功能：\n\n1. 一个基本的博客内容管理器功能，如后台登陆，发布并管理文章等\n2. 支持[markdown语法编辑](http://www.appinn.com/markdown/basic.html)\n3. 支持代码高亮\n4. 可以管理博客页面的链接\n5. 博客页面对移动端适配优化\n6. 账户管理(修改密码)\n7. 页面足够大气、酷炫嘿"
    }, {
        title: '博客用到的技术详解',
        date: new Date(),
        "content": "在用过臃肿的WordPress后，一直想自己写一个轻便简约的博客内容管理器(CMS)。\n\n##### 其实我想完成的功能：\n1. 一个基本的博客内容管理器功能，如后台登陆，发布并管理文章等\n2. 支持markdown语法编辑\n3. 支持代码高亮\n4. 可以管理博客页面的链接\n5. 博客页面对移动端适配优化\n6. 账户管理(修改密码)\n7. 页面足够大气、酷炫嘿\n\n## 用到的技术和实现思路：\n\n###### 前端：Vue全家桶\n* Vue.js\n* Vue-Cli\n* Vue-Resource\n* Vue-Validator\n* Vue-Router\n* Vuex\n* Vue-loader\n\n###### 后端\n* Node.js\n* mongoDB (mongoose)\n* Express\n\n###### 工具和语言\n* Webpack\n* ES6\n* SASS\n* Jade\n\n###### 整体思路：\n* Node服务端除了主页外，不做模板渲染，渲染交给浏览器完成\n* Node服务端不做任何路由切换的内容，这部分交给Vue-Router完成\n* Node服务端只用来接收请求，查询数据库并用来返回值\n\n所以这样做前后端几乎完全解耦，只要约定好restful风格的数据接口，和数据存取格式就OK啦。\n\n后端我用了mongoDB做数据库，并在Express中通过mongoose操作mongoDB，省去了复杂的命令行，通过Javascript操作无疑方便了很多。\n\n###### 简单的说一下Vue的各个插件：\n* Vue-Cli:官方的脚手架，用来初始化项目\n* Vue-Resource：可以看作一个Ajax库，通过在跟组件引入，可以方便的注入子组件。子组件以this.$http调用\n* Vue-Validator：用来验证表单\n* Vue-Router：官方的路由工具，用来切换子组件，是用来做SPA应用的关键\n* Vuex：控制组件中数据的流动，使得数据流动更加清晰，有迹可循。通过官方的vue-devtools可以无缝对接\n* Vue-loader：webpack中对Vue文件的加载器\n\n###### 上文件目录\n\n![dir](http://ycwalker.com/imgs/dir.png)\n\n我将前端的文件统一放到了src目录下，其中的mian.js是webpack的入口。\n\n所有页面分割成一个单一的vue组件，放在componentss中，通过入口文件mian.js，由webpack打包生成，生成的文件放在public文件夹下。\n\n后端文件放在server文件夹内，这就是基于Express的node服务器，在server文件夹内执行\n\n```\nnode www\n```\n就可以启动Node服务器，默认侦听3000端口。\n\n#### 关于Vue-Cli\n我只是使用了simple的template，相对于默认的template，simple的配置简单得多，但已经有了浏览器自动刷新，生产环境代码压缩等功能。\n```\nvue init simple CMS-of-Blog\n```\n\n以下是Vue-Cli生成的webpack的配置文件，我只做了一点小改动。\n\n话说React.js里就没用像Vue-Cli这样好用的脚手架，还是Vue.js简单优雅。。\n###### Webpack.config.js\n\n```\nvar path = require('path')\nvar webpack = require('webpack')\n\nmodule.exports = {\n    entry: './src/main.js',\n    output: {\n        path: path.resolve(__dirname, './public'),\n        publicPath: '/public/',\n        filename: 'build.js',\n    },\n    resolveLoader: {\n        root: path.join(__dirname, 'node_modules'),\n    },\n    module: {\n        loaders: [\n            {\n                test: /\\.vue$/,\n                loader: 'vue'\n            },\n            {\n                test: /\\.js$/,\n                loader: 'babel',\n                exclude: /node_modules/\n            },\n            {\n                test: /\\.json$/,\n                loader: 'json'\n            },\n            {\n                test: /\\.html$/,\n                loader: 'vue-html'\n            },\n            {\n                test: /\\.(png|jpg|gif|svg)$/,\n                loader: 'url',\n                query: {\n                    limit: 10000,\n                    name: '[name].[ext]?[hash]'\n                }\n            }\n            , {\n                test: /\\.(woff|svg|eot|ttf)\\??.*$/,\n                loader: 'url-loader?limit=50000&name=[path][name].[ext]'\n            }\n        ]\n    },\n    babel: {\n        presets: ['es2015'],\n    },\n    devServer: {\n        historyApiFallback: true,\n        noInfo: true\n    },\n    devtool: '#eval-source-map'\n}\n\nif (process.env.NODE_ENV === 'production') {\n    module.exports.devtool = '#source-map'\n    // http://vue-loader.vuejs.org/en/workflow/production.html\n    module.exports.plugins = (module.exports.plugins || []).concat([\n        new webpack.DefinePlugin({\n            'process.env': {\n                NODE_ENV: '\"production\"'\n            }\n        }),\n        new webpack.optimize.UglifyJsPlugin({\n            output: {\n                comments: false,\n            },\n            compress: {\n                warnings: false\n            }\n        }),\n        new webpack.optimize.OccurenceOrderPlugin()\n    ])\n}\n```\n\n可以看出尤大大帮我们把浏览器自动刷新，热加载和生产环境的代码压缩都写好了，简直超贴心。\n\n然而实际项目中，我还是碰到一个麻烦的问题，下面是package.json中的script脚本\n```\n\"scripts\": {\n    \"dev\": \"webpack-dev-server --inline --hot\",\n    \"build\": \"cross-env NODE_ENV=production webpack --progress --hide-modules\",\n    \"watch\": \"webpack --progress --color --watch\",\n    \"server\": \"supervisor ./server/www\"\n  },\n```\n运行\n```\nnpm run dev\n```\n后，浏览器在8080端口开了一个服务器，然而这个服务器是用来服务前端页面的，也就是说，从这里启动服务器而不是开启Node服务器会造成数据无法交互，毕竟这个服务器不能连接数据库。但这个端口是可以在文件修改之后自动刷新浏览器的。\n\n然后，通过分别执行\n```\nnpm run watch\nnpm run server\n```\n来侦听文件改动，并重启Node服务器，此时浏览器是不能自动刷新的。找了一些方法但终归没解决。习惯了自动浏览器刷新，碰到这种情况蛮蛋疼的。\n\n于是只好这样：\n\n在修改样式的时候使用8080端口的服务器，在修改数据交互的时候手动刷新在3000端口服务器的浏览器。\n\n虽然不是很方便，但至少通过supervisor不用自己重启Node服务器了。。。\n\n#### 关于Vue-Router\n\n因为写的是但也应用（SPA），服务器不负责路由，所以路由方面交给Vue-Router来控制。\n\n下面是根组件，路由控制就在这里，组件挂载在body元素下：\n###### main.js\n```\nlet router = new VueRouter()\n\nrouter.map({\n    '/': {\n        component: Archive\n    },\n    'login': {\n        component: Login\n    },\n    '/article': {\n        component: Article\n    },\n    '/console': {\n        component: Console,\n        subRoutes: {\n            '/': {\n                component: ArticleList\n            },\n            '/editor': {\n                component: Editor\n            },\n            '/articleList': {\n                component: ArticleList\n            },\n            '/menu': {\n                component: Links\n            },\n            'account': {\n                component: Account\n            },\n        },\n    },\n})\nlet App = Vue.extend({\n    data(){\n        return {}\n    },\n    components: {Waiting,Pop,NightSky,MyCanvas},\n    http: {\n        root: '/'\n    },\n    computed: {\n        waiting: ()=>store.state.waiting,\n        pop:()=>store.state.popPara.pop,\n        bg:()=>store.state.bg,\n    },\n    store\n})\n\nrouter.start(App, 'body')\n```\n###### 对应的文档首页 index.html\n```\n<!DOCTYPE html>\n<html lang=\"zh-CN\">\n  <head>\n    <title>Blog-CMS</title>\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  </head>\n  <body>\n    <waiting v-if=\"waiting\"></waiting>\n    <pop v-show=\"pop\"></pop>\n    <component :is=\"bg\"></component>\n    <router-view></router-view>\n    <script src=\"public/build.js\"></script>\n  </body>\n</html>\n```\n可以看到路由控制在body元素下的router-view中。之前的waiting，pop和component元素分别是等待效果（就是转圈圈）的弹出层，信息的弹出层，和背景样式的切换。\n\n其实这个index.html是有express通过jade生成的，实际项目中并没有html文件，我是把生成好的html放在这里方便展示。\n\n#### 关于Vue-loader\nVue-loader是Vue官方支持webpack的工具，用来将组件写在一个文件里。之前的目录中，有很多分割好的vue文件，每一个文件是一个独立的组件。\n\n比如，这是一个弹出层的组件：\n###### Pop.vue\n```\n<template>\n    <div class=\"shade\">\n        <div class=\"content\">\n            <p>{{getPopPara.content}}</p>\n            <div class=\"button\">\n                <button class=\"ok\" @click=\"ok\">确定</button>\n                <button class=\"cancel\" @click=\"cancel\"\n                        v-if=\"getPopPara.cb2\">取消\n                </button>\n            </div>\n        </div>\n    </div>\n</template>\n\n<script>\n    import {getPopPara} from '../vuex/getters'\n    export default{\n        vuex: {\n            getters: {\n                getPopPara,\n            }\n        },\n        methods: {\n            ok(){\n                let fn = this.getPopPara.cb1\n                typeof fn == 'function' && fn()\n            },\n            cancel(){\n                let fn = this.getPopPara.cb2\n                typeof fn == 'function' && fn()\n            }\n        }\n\n    }\n</script>\n<style lang=\"sass\">\n    @import \"../SCSS/Pop.scss\";\n</style>\n```\n每一个vue文件都有三个部分（其实是可选的），分别是template，script和style，这也很好理解，就是把html，JS和CSS合并在一起写了嘛。\n\n这个弹窗组件，通过vuex获得其他组件传递过来的参数，参数是一个对象，包括弹出层的展示信息和点击确定或取消时的回调函数。\n\n因为编辑器不支持在vue文件中用sass语法，所以我把sass文件放在外部，通过@import引入。\n\n#### 关于Vue-Resource\nVue-Resource可以看成一个与Vue集成的Ajax库，用来创建xhr和获取xhr的response。\n\n因为和Vue高度集成，所以在vue组件中使用很方便。\n###### Article.vue\n```\n<template>\n    <div class=\"wrap\">\n        <my-header></my-header>\n        <section class=\"article\">\n            <article class=\"post-block\">\n                <div class=\"post-title\">{{title}}</div>\n                <div class=\"post-info\">{{date}}</div>\n                <div class=\"post-content\"\n                 v-html=\"content | marked\">\n                </div>\n            </article>\n        </section>\n        <my-footer></my-footer>\n    </div>\n</template>\n<script>\n    import myHeader     from './MyHeader.vue'\n    import myFooter     from './MyFooter.vue'\n    import marked       from '../js/marked.min.js'\n    import {bgToggle}   from '../vuex/actions'\n\n    export default{\n        data(){\n            return {\n                title: '',\n                date: '',\n                content: ''\n            }\n        },\n        filters: {\n            marked\n        },\n        created(){\n            let id = this.$route.query.id\n            this.$http.get('/article?id=' + id)\n                    .then((response)=> {\n                        let body = JSON.parse(response.body)\n                        this.content = body.content\n                        this.title = body.title\n                        let d = new Date(body.date)\n                        this.date = d.getFullYear() + '年' +\n                                (d.getMonth() + 1) + '月' +\n                                d.getDate() + '日'\n                    }, (response)=> {\n                        console.log(response)\n                    })\n        },\n        components: {\n            myHeader,\n            myFooter\n        },\n        ready(){\n            this.bgToggle('MyCanvas')\n        },\n        vuex:{\n            actions:{\n                bgToggle\n            }\n        }\n    }\n</script>\n<style lang=\"sass\">\n    @import \"../SCSS/Article.scss\";\n</style>\n```\nArticle.vue组件种在created生命周期时创建并发送了一个xhr的get请求，在获取成果后把response对象中的属性在赋值给data中相应的属性，vue会自动更新视图。\n\n博客所支持的markdown语法的关键所在也在这个组件里。\n```\n<div class=\"post-content\">\n       {{{content | marked}}}\n</div>\n```\n通过引入markdown的filter使得输出的html直接被转换成html结构，还是很方便的。\n\n#### 关于后端\n\n后端是用node.js作为服务器的，使用了最流行Express框架。\n\n主体是由Express生成，本身十分精简。在实践中修改的地方主要是添加了各种前端发送的get和post请求。\n\n```\nrouter.get('/article', function (req, res, next) {\n    var id = req.query.id\n    db.Article.findOne({_id: id}, function (err, doc) {\n        if (err) {\n            return console.log(err)\n        } else if (doc) {\n            res.send(doc)\n        }\n    })\n})\n```\n比如这个请求处理来自前端的get请求，通过mongoose来查询数据库并返回数据。\n\n前端页面通过promise控制异步操作，把得到的数据放入组件的data对象中，Vue侦测变化并更新视图。\n\n数据库的初始化文件放在了init.js中，第一次运行的时候会新建名为admin的用户，初始密码为111，可以在控制台的账号管理中修改。\n\n#### 后记\n其实还有很多很多没有在这篇文章提及的地方。毕竟这个博客框架相对是比较大的东西。\n\n写过这个博客管理器后，感受还是蛮多的，对Vue.js中的数据绑定，组件化和数据流了解的更深入了一层，同时也对Node.js的后端有了一次优雅的实践。\n\n所以，学过东西之后，实践是非常有必要的。前端很多时候就是不断踩坑的过程。一路踩坑再爬坑，其实蛮有成就感的。",
    }],
    links: [{
        name: '首页',
        href: '/#!/', 
        newPage: false
    },{
        name: '设置',
        href: '#!/console', // 待修正，加上username
        newPage: false
    },{
        name: '原博客',
        href: 'http://weitianyao.com/',
        newPage: true
    } ]
}
